% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regularized_regression.R
\name{Regression_row}
\alias{Regression_row}
\title{Regularized linear regression Y ~ X}
\usage{
Regression_row(
  Y,
  X,
  lambda,
  THR = FALSE,
  SCALE = TRUE,
  ADAPTIVE = TRUE,
  crit = c("bic", "aic", "aicc", "hqc", "mbic2", "eric", "bic_m"),
  mbic2_c = 4,
  tau = 1,
  first.penalty.factor = NULL,
  ...
)
}
\arguments{
\item{Y}{vector y of length n}

\item{X}{matrix X of size n times p}

\item{lambda}{vector of tuning paramter lambda}

\item{THR}{flag to specify if thresholded (with lambda as threshold) beta should be returned.}

\item{SCALE}{flag to specify if X should be normalized prior to regularized regression}

\item{ADAPTIVE}{flag to specify if a second adaptive step should be performed}

\item{crit}{flag to specify which information criteria should be used}

\item{mbic2_c}{additinal parameter for some information criteria}

\item{tau}{if a second adptive is used, tau specifies the following penalty.factor=1/abs(abs(first.step.coef)+1/sqrt(n))^tau}

\item{first.penalty.factor}{penalty factors for the first step. NULL leads to uninformative first step factors.}

\item{...}{additional parameters}
}
\value{
list: coef: Best model according to used IC; eps: Residuals of best model; lam: optimal lambda accoirding to used IC; crit: Minimal value of used IC.
}
\description{
Computes the  regression Y=BETA X with l1 regularization. Uses LASSO (glmnet), a second adaptive step (penalty is chosen adaptively based on the first step (tau))
Penalty parameter is chosen by information criteria (crit), see also \code{\link{Regression_Row_IC}}.
}
\details{
Information criteria: (n sample size, p dimension, n_var number of non-zero variables)
bic = n * log(mse) + nvar * log(n)
mbic2 = n * log(mse) + nvar * (log(n)+log(p/mbic2_c))-2\emph{log(gamma(nvar+1))
aic = n * log(mse) + 2 * nvar
aicc = aic + (2 * nvar * (nvar + 1))/(n - nvar - 1)
hqc = n * log(mse) + 2 * nvar * log(log(n))
eric=n * log(mse) +nvar * log(sqrt(n}mse)/lambda)*ifelse(n>p,1,0.5)
bic_m = n * log(mse) + nvar * log(n)*mbic2_c
}
